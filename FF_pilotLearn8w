# -*- coding: utf-8 -*-
"""
Created on Mon Aug 06 12:23:19 2018

@author: Arella Gussow
"""


#for pilots
subject = 'i' #subj name
b=40 #sec till break
## participants see a break screen every so often (currently set to b = 40 sec)
## will not stop mid-trial - waits till post-trial.
## to continue, participants will press 'c'. 
## for experimenter only: 's' will quit experiment. participants do not know this.

###########words temporarily changed to Sav and Caf################
import random
import csv
import sys
import numpy as np
from psychopy import visual, core, event, gui
from collections import Counter


timer=core.Clock() #total time for learning phase




#define keys to be used and corresponding phonemes from stim creation
capKeys = {'S':'1','C':'2','g':'3','k':'4',
          'U':'c','a':'v','x':'n','i':'m','b':'8','p':'9','f':'0','v':'minus'}
keys=capKeys.values()

## NOT IN IPA!!!!! for programming purposes: sh=S, ch=C, oo=U, ee=x
allWords= ['SUb','CUp','gxf','kxv','Sav','Caf','gip','kib']


##running from pre-saved pics
win = visual.Window([960,600], fullscr=True,
                        color="white", units='pix')
breakText=visual.TextStim(win=win, height=40,
                 text="Please take a short break. Press 'c' to continue.",
                 color='grey')
endText=visual.TextStim(win=win, height=40,
                 text="All Done! Please call the experimenter.",
                 color='grey')

wrongText=visual.TextStim(win=win, height=40,
                 text="Look at the pattern again and give it another try.",
                 color='grey')


fixation= visual.ShapeStim(win, vertices=((0, -80), (0, 80), (0,0), 
                                               (80,0), (-80, 0)),
                                        lineWidth=5, closeShape=False, 
                                        lineColor='grey')
# keyboard color pattern:
pic1 = visual.ImageStim(win=win, mask=None,interpolate=False,pos=(0,0), size=(1040,650))

#shape on bottom left of pic1:
picShape= visual.ImageStim(win=win, mask=None,interpolate=False,pos=(-500,-300), size=(127,123))

#shape in the middle of the screen (testing knowledge of shape, without background pattern)
picTest = visual.ImageStim(win=win, mask=None,interpolate=False,pos=(0,0), size=(127,123))


## shows keyboard template, with three keys colored blue, yellow, red (order of press).
## on bottom left of screen is tha shape associated with this sequence. 
## once participant presses the whole sequence, keyboard template dissapears and only the
## associated shape appears in the middle of the screen, as a cue for participants 
## to press the previously learned sequence. 
## if wrong, text shows up saying so and they must try again.
## if right, repetition begins testing all shapes already learned * 4. At any error,
## pattern re-displayed for that shape. once repetition completed, new word learned, 
## and new repetition round begins including it.


## the following functions:
## showTap = presenting keyboard template and shape.
## testShape = presenting only shape mid screen 
## gimmeAbreak = show break screen

## task run begins below defining functions 


def showTap(word):
    while True: 
        viewAcc=[]        
        pic1.setImage('8w_constrained/'+word+'_8wFF.png')
        pic1.draw()
        picShape.setImage('Shapes/'+word+'.png')
        picShape.draw()
        win.flip()
        capInd=1
        for curCap in word:
            response=(event.waitKeys(keyList=keys))[0]
            if response==capKeys[curCap]:
                viewAcc.append(response)                    
            string=[str(var) for var in word, curCap, response, 
                    capKeys[curCap], len(viewAcc)]
            print string
            capInd+=1                 
        if len(viewAcc)<3:
            core.wait(1)
            viewAcc=[]
            wrongText.draw()
            win.flip()
            core.wait(1)
        elif len(viewAcc)==3:
            core.wait(1)
            break
        gimmeAbreak(breakTime) 


errMonitor =[] #appends shape name of test item if participant made an error
tested=set() #set of words that have been tested, regardless of freq

def testShape(word):
    while True: 
        testAcc=[]         
        picTest.setImage('Shapes/'+word+'.png')
        picTest.draw()
        win.flip()
        capInd=1
        for curCap in word:
            response=(event.waitKeys(keyList=keys))[0]
            if response==capKeys[curCap]:
                testAcc.append(response)                    
            string=[str(var) for var in word, curCap, response, 
                    capKeys[curCap], len(testAcc)]
            print string
            line='\t'.join(string) + '\n'
            resultsFile.write(line)
            resultsFile.flush()          
            capInd+=1                 
        if len(testAcc)<3:
            core.wait(.5)
            errMonitor.append(word)           
            testAcc=[]
            wrongText.draw()
            win.flip()            
            core.wait(1)
            showTap(word)
            break
        elif len(testAcc)==3:
            if word not in tested:
                tested.update([word])
            core.wait(.5)
            break

        string=[str(var) for var in trialNum, word, len(testAcc)]
        print string
        core.wait(.5)           
        fixation.draw()
        win.flip()
        core.wait(.5)
        gimmeAbreak(breakTime) 



def gimmeAbreak(breakTime):
    if int(breakTime.getTime())>40:
            breakClick=False
            while not breakClick:
                breakText.draw()
                win.flip()
                stop= event.waitKeys(['c','s'])
                if stop==['c']:
                    breakTime.reset()
                    breakClick=True
                elif stop==['s']:
                    win.close()
                    core.quit()

allWords= ['gxf','kxv','Sav','Caf','gip','kib','SUb','CUp']
backMonitor =[] #counter - appends shape name every time it's presented as backtest item


#### TASK RUN BEGINS HERE ### 
with open(subject+'_learn8w.txt','w') as resultsFile:
    core.wait(2)
    breakTime=core.Clock()
    trialNum=0
    for word in allWords:
        showTap(word)
        testShape(word)
        fixation.draw()
        win.flip()
        core.wait(1)
        if len(tested)>1:
            backTest=(list(tested))*4
            random.shuffle(backTest)
            backMonitor.extend([x for x in backTest])
            for t in backTest:
                testShape(t)
                fixation.draw()
                win.flip()
                core.wait(1)        
           
            gimmeAbreak(breakTime)
    fill =[]
    count = {word: backMonitor.count(word) for word in allWords}
    
    ## the following checks for each word how many more repetitions it needs to
    ## reach 40. the first words learned have been repeated more times (7*4),
    ## so this ensures equal frequency for all; reaching 10*4. "fill" is a 
    ## list of the words, each multiplied by the number of times it's missing,
    ## 'fill' is then shuffled randomly and each word is presented as above.
    
    for word in allWords:
        remain=40-count[word]
        fill.extend([word for i in range(remain)])
    random.shuffle(fill)
    print len(backTest)
    for word in fill:
        testShape(word)
        fixation.draw()
        win.flip()
        core.wait(1)
    
    ##sanity check that each word was tested 40 times
    count = {word: backMonitor.count(word) for word in allWords}
    ##count errors for each word
    errCount={word: errMonitor.count(word) for word in allWords}
    ##proportion of errors out of times tested for each word
    errProp= {word: (int((errMonitor.count(word)/40.0)*100)) for word in allWords}
    ##stop clock to see how long experiment was
    totalTime=int(timer.getTime())

    ##not included in results file, just printed to console for sanity check
    print count
    print errCount
    print errProp
    print totalTime          
    endText.draw()
    monitor=[str(var) for var in backMonitor, errMonitor, totalTime, 
             count.values(), errCount.keys(),errCount.values()]
    line='\t'.join(monitor) + '\n'
    resultsFile.write(line)
    resultsFile.flush() 
    resultsFile.close()
    win.flip()
    core.wait(5)
    win.close()
win.close()
core.quit()
